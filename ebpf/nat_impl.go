package main

// TC-based DNAT using eBPF.
//
// The eBPF C source lives in nat.c; bpf2go compiles it and emits
// nat_bpfel.go / nat_bpfeb.go with the natObjects / loadNatObjects API.
//
// Build:
//   make generate   # runs go:generate in gen.go -> produces nat_bpf*.go
//   go build -o nat-demo .
//
// Run (example: rewrite dst 10.0.0.1:80 -> 10.0.0.2:8080 on eth0):
//   sudo ./nat-demo nat -iface eth0 -dst-ip 10.0.0.1 -dst-port 80 \
//                       -new-ip 10.0.0.2 -new-port 8080

import (
	"encoding/binary"
	"flag"
	"fmt"
	"log"
	"net"
	"os"
	"os/signal"
	"syscall"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
)

// natKey mirrors struct nat_key in nat.c.
// Fields are in host byte order here; ipToUint32 returns network byte order
// to match what the kernel stores in ip->daddr / tcp->dest.
type natKey struct {
	DstIP   uint32
	DstPort uint16
	Proto   uint8
	Pad     uint8
}

// natTarget mirrors struct nat_target in nat.c.
type natTarget struct {
	NewIP   uint32
	NewPort uint16
	Pad     [2]uint8
}

func RunNAT(args []string) {
	fs := flag.NewFlagSet("nat", flag.ExitOnError)
	iface := fs.String("iface", "eth0", "network interface to attach TC program")
	dstIP := fs.String("dst-ip", "", "original destination IP to match")
	dstPort := fs.Uint("dst-port", 80, "original destination port to match")
	newIP := fs.String("new-ip", "", "new destination IP")
	newPort := fs.Uint("new-port", 8080, "new destination port")
	proto := fs.String("proto", "tcp", "protocol to match: tcp or udp")
	fs.Parse(args) //nolint:errcheck

	if *dstIP == "" || *newIP == "" {
		log.Fatal("both -dst-ip and -new-ip are required")
	}

	var protoNum uint8
	switch *proto {
	case "tcp":
		protoNum = 6
	case "udp":
		protoNum = 17
	default:
		log.Fatalf("unsupported protocol %q (use tcp or udp)", *proto)
	}

	// Allow locking memory for eBPF maps.
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatalf("removing memlock: %v", err)
	}

	// Load compiled eBPF objects (generated by bpf2go from nat.c).
	objs := natObjects{}
	if err := loadNatObjects(&objs, nil); err != nil {
		log.Fatalf("loading eBPF objects: %v", err)
	}
	defer objs.Close()

	// Resolve interface.
	netIface, err := net.InterfaceByName(*iface)
	if err != nil {
		log.Fatalf("interface %s: %v", *iface, err)
	}

	// Attach TC ingress program via TCX (requires kernel >= 6.6).
	tcLink, err := link.AttachTCX(link.TCXOptions{
		Interface: netIface.Index,
		Program:   objs.TcDnat,
		Attach:    ebpf.AttachTCXIngress,
	})
	if err != nil {
		log.Fatalf("attaching TC program to %s: %v", *iface, err)
	}
	defer tcLink.Close()

	log.Printf("TC DNAT attached to %s ingress", *iface)

	// Insert NAT rule.
	// IPs are stored in network byte order (big-endian) to match ip->daddr.
	// Ports are stored in host byte order to match the key built in C
	// via bpf_ntohs(tcp->dest).
	key := natKey{
		DstIP:   ipToUint32BE(*dstIP),
		DstPort: uint16(*dstPort),
		Proto:   protoNum,
	}
	target := natTarget{
		NewIP:   ipToUint32BE(*newIP),
		NewPort: uint16(*newPort),
	}

	if err := objs.NatRules.Put(key, target); err != nil {
		log.Fatalf("inserting NAT rule: %v", err)
	}
	log.Printf("DNAT rule: %s:%d -> %s:%d (%s)",
		*dstIP, *dstPort, *newIP, *newPort, *proto)
	log.Println("Press Ctrl+C to detach.")

	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
	<-sig
	fmt.Println("\ndetaching TC program...")
}

// ipToUint32BE converts a dotted-decimal IPv4 string to a big-endian uint32,
// matching the network byte order used by the kernel in ip->daddr.
func ipToUint32BE(s string) uint32 {
	ip := net.ParseIP(s).To4()
	if ip == nil {
		log.Fatalf("invalid IPv4 address: %s", s)
	}
	return binary.BigEndian.Uint32(ip)
}
